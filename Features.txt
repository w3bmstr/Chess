Features will be used to make the navigation.

♟️ FEATURES.md — Chess2 Master Feature Catalog
(Organized, complete, ready for prioritization)
1. Core Engine
Move Generation
Bitboard Movegen — Core Engine — — — Daniel — 64‑bit BigInt bitboards

Magic Bitboards — Core Engine — — — Daniel — Sliding piece attack tables

Pawn Logic — Core Engine — — — Daniel — Promotions, en passant, structure

Legal Move Filtering — Core Engine — — — Daniel — Remove illegal moves

Check/Pin Detection — Core Engine — — — Daniel — King safety logic

Move Ordering — Core Engine — — — Daniel — MVV‑LVA, killers, history

Zero‑GC Movegen — Core Engine — — — Daniel — No allocations during search

Packed Move Encoding — Core Engine — — — Daniel — 32‑bit or 16‑bit format

Make/Unmake — Core Engine — — — Daniel — Reversible state

Zobrist Hashing — Core Engine — — — Daniel — Hash keys for TT

Search
Alpha‑Beta Search — Core Engine — — — Daniel — Main search algorithm

Iterative Deepening — Core Engine — — — Daniel — Depth‑by‑depth search

Transposition Table — Core Engine — — — Daniel — Hash table for caching

Null‑Move Pruning — Core Engine — — — Daniel — Aggressive pruning

Late Move Reductions — Core Engine — — — Daniel — LMR heuristics

Aspiration Windows — Core Engine — — — Daniel — Narrow search windows

Quiescence Search — Core Engine — — — Daniel — Capture search

Futility Pruning — Core Engine — — — Daniel — Skip hopeless nodes

Singular Extensions — Core Engine — — — Daniel — Extend forced lines

Multi‑PV — Core Engine — — — Daniel — Multiple best lines

Time Management — Core Engine — — — Daniel — Clock‑aware search

Search Abort Signals — Core Engine — — — Daniel — Stop search safely

Evaluation
Material Evaluation — Core Engine — — — Daniel — Base scoring

PST Evaluation — Core Engine — — — Daniel — Piece‑square tables

Mobility Evaluation — Core Engine — — — Daniel — Move count scoring

King Safety — Core Engine — — — Daniel — Attacks, shelter

Pawn Structure — Core Engine — — — Daniel — Doubled, isolated, passed

Space Evaluation — Core Engine — — — Daniel — Territory control

Threat Evaluation — Core Engine — — — Daniel — Hanging pieces

NNUE Hooks — Core Engine — — — Daniel — Neural eval integration

Endgame
Syzygy Tablebase Probe — Core Engine — — — Daniel — Perfect endgames

Mate Distance — Core Engine — — — Daniel — DTM scoring

Endgame Heuristics — Core Engine — — — Daniel — Simplified logic

2. Game Play
Board Interaction
Drag & Drop — Game Play — — — Daniel — Standard movement

Click‑to‑Move — Game Play — — — Daniel — Alternative input

Piece Animations — Game Play — — — Daniel — Smooth sliding

Ghost Piece — Game Play — — — Daniel — Drag preview

Legal Move Highlighting — Game Play — — — Daniel — Dots or circles

Last Move Highlight — Game Play — — — Daniel — From/to squares

Check Highlight — Game Play — — — Daniel — King in check

Coordinates — Game Play — — — Daniel — Files/ranks

Board Flip — Game Play — — — Daniel — White/Black perspective

Themes — Game Play — — — Daniel — Board skins

Piece Sets — Game Play — — — Daniel — Visual styles

Resizeable Board — Game Play — — — Daniel — Responsive

Mobile Gestures — Game Play — — — Daniel — Touch support

Visual Markup
Arrows — Game Play — — — Daniel — Right‑click

Circles — Game Play — — — Daniel — Right‑click

Multi‑Color Arrows — Game Play — — — Daniel — Red/green/yellow/blue

Engine Arrows — Game Play — — — Daniel — Best move

Threat Highlights — Game Play — — — Daniel — Attacked squares

Hanging Piece Highlights — Game Play — — — Daniel — Free captures

3. Controls & Navigation
Move Navigation
First Move — Controls — — — Daniel — Jump to start

Previous Move — Controls — — — Daniel — Step back

Next Move — Controls — — — Daniel — Step forward

Last Move — Controls — — — Daniel — Jump to end

Undo — Controls — — — Daniel — Reverse last move

Redo — Controls — — — Daniel — Reapply move

Rewind — Controls — — — Daniel — Jump to start

Fast‑Forward — Controls — — — Daniel — Jump to end

Keyboard Shortcuts — Controls — — — Daniel — Arrow keys

Game Actions
New Game — Controls — — — Daniel — Reset board

Resign — Controls — — — Daniel — End game

Offer Draw — Controls — — — Daniel — Request draw

Accept/Decline Draw — Controls — — — Daniel — Respond to offer

Claim Draw — Controls — — — Daniel — 50‑move, repetition

Takeback Request — Controls — — — Daniel — Multiplayer

Auto‑Promotion Settings — Controls — — — Daniel — Queen/ask

Autoplay
Engine vs Engine — Controls — — — Daniel — Self‑play

Adjustable Speed — Controls — — — Daniel — Fast/slow

Pause/Resume — Controls — — — Daniel — Control autoplay

Auto‑Flip — Controls — — — Daniel — Flip each move

Auto‑Annotate — Controls — — — Daniel — Auto comments

4. Notation & Storage
Move List
SAN Notation — Notation — — — Daniel — Standard notation

LAN Notation — Notation — — — Daniel — Long algebraic

UCI Notation — Notation — — — Daniel — Engine format

Scrollable Move List — Notation — — — Daniel — UI list

Click to Jump — Notation — — — Daniel — Navigate by clicking

Variations — Notation — — — Daniel — Branches

Comments — Notation — — — Daniel — User notes

Move Annotations — Notation — — — Daniel — ! ? !! ??

Import/Export
PGN Import — Notation — — — Daniel — Load games

PGN Export — Notation — — — Daniel — Save games

FEN Load — Notation — — — Daniel — Load position

FEN Save — Notation — — — Daniel — Save position

EPD Support — Notation — — — Daniel — Position format

Clipboard Copy — Notation — — — Daniel — Quick copy

File Upload/Download — Notation — — — Daniel — Local files

Position Editor
Drag Pieces — Notation — — — Daniel — Setup board

Set Side to Move — Notation — — — Daniel — White/Black

Set Castling Rights — Notation — — — Daniel — KQkq

Set En Passant — Notation — — — Daniel — EP square

Validate Position — Notation — — — Daniel — Legal check

5. Analysis & Engine Feedback
Evaluation
Eval Bar — Analysis — — — Daniel — Visual score

Numeric Score — Analysis — — — Daniel — +1.23

Mate Score — Analysis — — — Daniel — M3

Blunder Detection — Analysis — — — Daniel — Move quality

Move Quality Classification — Analysis — — — Daniel — Good/Bad

PV Display
Best Line — Analysis — — — Daniel — PV

Multi‑PV — Analysis — — — Daniel — Top N lines

Highlight PV — Analysis — — — Daniel — On board

Depth — Analysis — — — Daniel — Search depth

Nodes — Analysis — — — Daniel — Node count

NPS — Analysis — — — Daniel — Nodes/sec

Hash Full — Analysis — — — Daniel — TT usage

TB Hits — Analysis — — — Daniel — Tablebase

Time Spent — Analysis — — — Daniel — Search time

Special Modes
Infinite Analysis — Analysis — — — Daniel — No time limit

Threat Mode — Analysis — — — Daniel — Opponent move

Hint Mode — Analysis — — — Daniel — 3 levels

Search Logs — Analysis — — — Daniel — Debug info

6. Opening & Endgame Tools
Opening Explorer
Polyglot Book — Opening Tools — — — Daniel — .bin files

Win/Draw/Loss Stats — Opening Tools — — — Daniel — Percentages

Move Popularity — Opening Tools — — — Daniel — Frequency

ECO Codes — Opening Tools — — — Daniel — A00–E99

Opening Names — Opening Tools — — — Daniel — Named lines

Player Database — Opening Tools — — — Daniel — Optional

Endgame Tools
Tablebase Probe — Endgame Tools — — — Daniel — Syzygy

Perfect Play Lines — Endgame Tools — — — Daniel — DTM

Mate Distance — Endgame Tools — — — Daniel — DTM

Endgame Classification — Endgame Tools — — — Daniel — KPK, KRK, etc.

7. Training & Puzzles
Puzzles
Daily Puzzle — Training — — — Daniel — One per day

Puzzle Rush — Training — — — Daniel — Timed

Puzzle Battle — Training — — — Daniel — Competitive

Thematic Puzzles — Training — — — Daniel — Openings

Difficulty Rating — Training — — — Daniel — Elo

Rating System — Training — — — Daniel — Puzzle Elo

Streaks — Training — — — Daniel — Consecutive solves

Hints — Training — — — Daniel — Multi‑tier

Retry — Training — — — Daniel — Try again

Puzzle Explanations — Training — — — Daniel — Why solution works

Puzzle Database Import — Training — — — Daniel — External DB

Training Modes
Blindfold Mode — Training — — — Daniel — No pieces

Guess the Move — Training — — — Daniel — GM games

Tactics Trainer — Training — — — Daniel — Random puzzles

Endgame Trainer — Training — — — Daniel — KPK, KRK

Visualization Drills — Training — — — Daniel — Board memory

Knight‑Vision Drills — Training — — — Daniel — Knight patterns

Memory Mode — Training — — — Daniel — Recall positions

8. Game Modes & Rules
Single Player
Human vs Engine — Game Modes — — — Daniel — Standard

Engine vs Engine — Game Modes — — — Daniel — Self‑play

Adjustable Strength — Game Modes — — — Daniel — Difficulty

Time Controls — Game Modes — — — Daniel — Blitz, rapid

Increment/Delay — Game Modes — — — Daniel — Fischer

Handicap Modes — Game Modes — — — Daniel — Odds

Variants
Chess960 — Game Modes — — — Daniel — Random back rank

King of the Hill — Game Modes — — — Daniel — Center win

Three‑Check — Game Modes — — — Daniel — 3 checks wins

Horde — Game Modes — — — Daniel — Pawn horde

Atomic — Game Modes — — — Daniel — Explosions

Crazyhouse — Game Modes — — — Daniel — Drops

Bughouse — Game Modes — — — Daniel — Partner

Capablanca/Gothic — Game Modes — — — Daniel — 10×8

Custom Variants — Game Modes — — — Daniel — User‑defined

9. Multiplayer & Social
Live Games — Multiplayer — — — Daniel — Real‑time

Matchmaking — Multiplayer — — — Daniel — Rating‑based

Spectate — Multiplayer — — — Daniel — Watch games

Chat — Multiplayer — — — Daniel — Messaging

Rematch — Multiplayer — — — Daniel — Replay

Rating System — Multiplayer — — — Daniel — Elo

Leaderboards — Multiplayer — — — Daniel — Rankings

Tournaments — Multiplayer — — — Daniel — Brackets

Clubs/Teams — Multiplayer — — — Daniel — Groups

10. UI, UX & Accessibility
Dark/Light Themes — UI/UX — — — Daniel — Visual modes

High Contrast — UI/UX — — — Daniel — Accessibility

Colorblind Mode — UI/UX — — — Daniel — Red/green safe

Adjustable Fonts — UI/UX — — — Daniel — Scaling

ARIA Labels — UI/UX — — — Daniel — Screen readers

Keyboard Navigation — UI/UX — — — Daniel — Accessibility

Sound Effects — UI/UX — — — Daniel — Move sounds

Move Confirmation — UI/UX — — — Daniel — Tap twice

Animation Toggle — UI/UX — — — Daniel — Performance

11. Integrations
PGN/FEN/EPD — Integrations — — — Daniel — Formats

Polyglot — Integrations — — — Daniel — Opening book

Lichess API — Integrations — — — Daniel — Online data

Chess.com  API — Integrations — — — Daniel — Online data

Cloud Save — Integrations — — — Daniel — Sync

Share Game Link — Integrations — — — Daniel — URL

Export Board Image — Integrations — — — Daniel — PNG

Import from URL — Integrations — — — Daniel — Load remote

UCI/XBoard Protocol — Integrations — — — Daniel — Engine adapters

12. Developer & Debug Tools
Perft Runner — Dev Tools — — — Daniel — Movegen testing

Move Inspector — Dev Tools — — — Daniel — Debug moves

Zobrist Viewer — Dev Tools — — — Daniel — Hash keys

TT Inspector — Dev Tools — — — Daniel — Tablebase

Search Tree Visualizer — Dev Tools — — — Daniel — Debug search

Logging Console — Dev Tools — — — Daniel — Engine logs

Benchmark Mode — Dev Tools — — — Daniel — Speed tests

Stress Test — Dev Tools — — — Daniel — Stability

13. Monetization & Licensing
Pro Features — Monetization — — — Daniel — Paid extras

Subscription — Monetization — — — Daniel — Monthly

One‑Time Purchase — Monetization — — — Daniel — Lifetime

Cloud Analysis Credits — Monetization — — — Daniel — Paid compute

Puzzle Packs — Monetization — — — Daniel — DLC

Cosmetic Themes — Monetization — — — Daniel — Paid skins

Offline Mode — Monetization — — — Daniel — Local engine

Commercial Licensing — Monetization — — — Daniel — Sell engine
1. Feature taxonomy to capture everything
Use these top‑level categories to file every idea you have. Each category has the typical subareas so you don’t miss anything.

Core Engine  
Movegen; make/unmake; bitboards; BigInt; magic tables; search; TT; evaluation; NNUE hooks; perft; tablebase probe.

Game Play  
Board UI; drag/drop; animations; legal highlighting; flip board; coordinates; last move highlight; move confirmation; auto‑promotion rules.

Controls and Navigation  
Start, Prev, Next, End; undo/redo; rewind/fast‑forward; autoplay; pause; speed control; keyboard shortcuts.

Notation and Storage  
SAN move list; PGN import/export; FEN load/save; game metadata; clipboard copy; download/upload.

Analysis and Engine Feedback  
Eval bar; multi‑PV; PV list; depth/nodes/nps; TB hits; threat mode; hint system; infinite analysis; search logs.

Opening and Endgame Tools  
Opening book explorer; polyglot probe; statistics; syzygy integration; endgame tablebase viewer.

Training and Puzzles  
Puzzle database; difficulty levels; hint tiers; scoring; progress tracking; timed puzzles; blindfold mode.

Game Modes and Rules  
Casual, Rated, Correspondence, Time controls, Fischer increments, Chess960, variants (bughouse, crazyhouse).

Multiplayer and Social  
Live games; matchmaking; spectate; chat; game sharing; leaderboards; accounts.

UI, UX and Accessibility  
Themes; colorblind mode; font sizes; ARIA labels; keyboard navigation; high contrast; sound effects.

Import / Export and Integrations  
PGN, FEN, EPD, Polyglot, Lichess API, Chess.com  API, cloud save, GitHub pages demo.

Developer and Debug Tools  
Perft runner; move inspector; zobrist dump; TT inspector; profiling; developer mode toggle.

Monetization and Licensing  
Open source license; paid features; analytics; telemetry; privacy settings.

2. Capture template for each feature
When you add an item, use this single line template so everything is comparable.

Feature Title — Category — Priority — V1/V2/Deferred/Excluded — Owner — Notes (1–2 lines)

Example
Puzzles with Hints — Training and Puzzles — High — V2 — Daniel — Needs puzzle DB, hint engine, scoring rules.

Keep a single master file FEATURES.md and append entries with that template.

3. Prioritization matrix you can use instantly
Score each feature on three axes 1–5 and compute a simple priority score.

Impact (user value)

Effort (dev time) — inverse: lower is better

Dependency Risk (how many other systems it touches)

Priority Score = Impact × (6 − Effort) × (6 − DependencyRisk)

Sort descending. This gives you a pragmatic ordering that balances value and feasibility.

4. Decision gates and the nav freeze rule
You already like locking decisions. Use these gates:

Design Freeze — wireframes, nav, and feature matrix approved. No top‑level nav changes without a DCR.

API Freeze — engine public API contract approved. Any API change requires a DCR and migration notes.

Content Freeze — data heavy features (puzzles, opening DB) require a separate content plan and license review.

DCR template minimal fields: Change Summary, Files Affected, UI Impact, Dev Effort, Rollback Plan, Owner.

5. Minimal viable product suggestion from the full list
If you truly want everything eventually, start with a tight MLP that proves the engine and UI:

V1 MLP

Core Engine (movegen, search, eval)

Play View (board, drag/drop, legal highlighting, flip)

Move List (SAN) + PGN/FEN import/export

Move Navigation (start/back/forward/end, undo/redo)

Evaluation Bar + basic engine stats

Autoplay demo mode

Worker integration for nonblocking UI

Everything else becomes V2 or later. This keeps the first release focused and demonstrable.

6. Next practical step for us right now
If you want, paste your current file tree and a handful of features you already care about. I will:

normalize the file tree into a locked proposal,

convert your raw wishlist into FEATURES.md entries using the template,

run the prioritization matrix and return a ranked V1/V2 plan, and

produce the exact DCR template and a sample DCR for “Add Puzzles” so you can see the cost and impact.

You’re doing the right thing by listing everything first. I’ll help you turn that list into a disciplined plan that keeps your nav and scope exactly how you want them.

no open source
Understood — you don’t want this project to be open source. That’s a clear, valid choice. Below is a concise, practical plan that covers legal status, distribution options, protection strategies, and immediate next steps so the repo and product are set up correctly from day one.

Quick summary
Yes: your code is automatically copyrighted the moment you write it.

No open source: choose a proprietary/commercial license or dual‑license model.

Decisions to make now: distribution model (closed repo vs. paid product vs. SaaS), contributor policy, and enforcement approach.

Licensing & legal options (pick one)
1. Fully proprietary (recommended if you want closed source)

Keep repo private.

Add a Proprietary License / EULA file that states usage restrictions, redistribution rules, and commercial terms.

Use a short license header in each source file referencing the EULA.

2. Dual licensing (open + commercial)

Offer a permissive open license for noncommercial use and a paid commercial license for companies.

Requires clear license text and a commercial license agreement.

3. Source-available but restricted

Publish code but with a restrictive license (no commercial use, no forks).

Easier for demos but still risky: “source‑available” is not the same as open source.

4. SaaS-only (no code distribution)

Keep engine code private and expose functionality via a hosted API or web app.

Best for monetization and control; you never ship the core IP.

Practical protections and policies
Copyright

You already own the copyright. Add a copyright header to each file:

© 2026 Daniel. All rights reserved.

License file

Add LICENSE or EULA.txt at repo root with explicit terms (usage, redistribution, liability, jurisdiction).

Contributor policy

If you accept outside contributions later, require a Contributor License Agreement (CLA) or Developer Assignment to ensure you own contributed code.

Access control

Keep the repo private (GitHub/GitLab/Bitbucket). Use branch protections and PR reviews.

Technical deterrents

Minify/obfuscate distributed builds (client bundles) to make copying harder.

Ship critical logic server‑side (SaaS) where possible.

Enforcement

Monitor for leaks (code search, GitHub search alerts).

Be prepared to send DMCA takedown notices or legal cease‑and‑desist if needed.

Optional IP steps

Consider patents only if you have a novel algorithm or business method worth protecting (expensive and slow).

Trade secret protection: NDAs for contractors, limited access, and internal policies.

Distribution & monetization choices
Closed repo + downloadable paid license — sell compiled bundles or installers.

Closed repo + SaaS — host engine and charge per usage or subscription.

Freemium — limited free demo, paid pro features (book, NNUE, higher hash).

Commercial license + evaluation builds — time‑limited or watermarked builds for evaluation.

Immediate next steps I recommend (practical, do‑this‑now)
Decide distribution model (Closed repo / SaaS / Dual license).

Create LICENSE/EULA.txt with clear terms and copyright notice.

Add file headers to source files referencing the license.

Make repo private and set branch protections.

Draft a short CLA if you might accept contributions later.

Decide what to ship publicly (demo site, minified bundle) and what stays private (core engine).

Add a DECISIONS.md entry: “Project is proprietary; puzzles excluded; DCR required for nav changes” so scope governance is recorded.

I can help with any of these next actions
Draft a proprietary license / EULA tailored to your needs.

Create a copyright header template for all files.

Draft a CLA or contributor policy.

Produce a short distribution plan (SaaS vs. binary vs. demo) with pros/cons.

Tell me which of the immediate steps you want me to draft first and I’ll produce a ready‑to‑paste artifact (license text, header template, or CLA) you can drop into the repo.
